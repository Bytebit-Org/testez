{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TestEZ is a BDD-style testing framework for Roblox Lua. We use TestEZ at Roblox for testing our apps, in-game core scripts, built-in Roblox Studio plugins, as well as libraries like Roact and Rodux . It provides an API that can run all of your tests with a single method call as well as a more granular API that exposes each step of the pipeline.","title":"Home"},{"location":"api-reference/","text":"Inside Tests \u00b6 describe \u00b6 describe(phrase, callback) This function creates a new describe block. These blocks correspond to the things that are being tested. Put it blocks inside of describe blocks to describe what behavior should be correct. For example: describe ( \"This cheese\" , function () it ( \"should be moldy\" , function () expect ( cheese . moldy ). to . equal ( true ) end ) end ) it \u00b6 it(phrase, callback) This function creates a new 'it' block. These blocks correspond to the behaviors that should be expected of the thing you're testing. For example: it ( \"should add 1 and 1\" , function () expect ( 1 + 1 ). to . equal ( 2 ) end ) itFOCUS and itSKIP \u00b6 itFOCUS(phrase, callback) itSKIP(phrase, callback) These methods are special versions of it that automatically mark the it block as focused or skipped . They're necessary because FOCUS and SKIP can't be called inside it blocks! FOCUS \u00b6 FOCUS() When called inside a describe block, FOCUS() marks that block as focused . If there are any focused blocks inside your test tree, only focused blocks will be executed, and all other tests will be skipped. When you're writing a new set of tests as part of a larger codebase, use FOCUS() while debugging them to reduce the amount of noise you need to scroll through. For example: describe ( \"Secret Feature X\" , function () FOCUS () it ( \"should do something\" , function () end ) end ) describe ( \"Secret Feature Y\" , function () it ( \"should do nothing\" , function () -- This code will not run! end ) end ) Note FOCUS does not work inside an it block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run. SKIP \u00b6 SKIP() This function works similarly to FOCUS() , except instead of marking a block as focused , it will mark a block as skipped , which stops any of the test assertions in the block from being executed. Note SKIP does not work inside an it block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run. expect \u00b6 expect(value) Creates a new Expectation , used for testing the properties of the given value. Expectations are intended to be read like English assertions. These are all true: -- Equality expect ( 1 ). to . equal ( 1 ) expect ( 1 ). never . to . equal ( 2 ) -- Approximate equality expect ( 5 ). to . be . near ( 5 + 1e-8 ) expect ( 5 ). to . be . near ( 5 - 1e-8 ) expect ( math.pi ). never . to . be . near ( 3 ) -- Optional limit parameter expect ( math.pi ). to . be . near ( 3 , 0.2 ) -- Nil checking expect ( 1 ). to . be . ok () expect ( false ). to . be . ok () expect ( nil ). never . to . be . ok () -- Type checking expect ( 1 ). to . be . a ( \"number\" ) expect ( newproxy ( true )). to . be . a ( \"userdata\" ) -- Function throwing expect ( function () error ( \"nope\" ) end ). to . throw () expect ( function () -- I don't throw! end ). never . to . throw ()","title":"API Reference"},{"location":"api-reference/#inside-tests","text":"","title":"Inside Tests"},{"location":"api-reference/#describe","text":"describe(phrase, callback) This function creates a new describe block. These blocks correspond to the things that are being tested. Put it blocks inside of describe blocks to describe what behavior should be correct. For example: describe ( \"This cheese\" , function () it ( \"should be moldy\" , function () expect ( cheese . moldy ). to . equal ( true ) end ) end )","title":"describe"},{"location":"api-reference/#it","text":"it(phrase, callback) This function creates a new 'it' block. These blocks correspond to the behaviors that should be expected of the thing you're testing. For example: it ( \"should add 1 and 1\" , function () expect ( 1 + 1 ). to . equal ( 2 ) end )","title":"it"},{"location":"api-reference/#itfocus-and-itskip","text":"itFOCUS(phrase, callback) itSKIP(phrase, callback) These methods are special versions of it that automatically mark the it block as focused or skipped . They're necessary because FOCUS and SKIP can't be called inside it blocks!","title":"itFOCUS and itSKIP"},{"location":"api-reference/#focus","text":"FOCUS() When called inside a describe block, FOCUS() marks that block as focused . If there are any focused blocks inside your test tree, only focused blocks will be executed, and all other tests will be skipped. When you're writing a new set of tests as part of a larger codebase, use FOCUS() while debugging them to reduce the amount of noise you need to scroll through. For example: describe ( \"Secret Feature X\" , function () FOCUS () it ( \"should do something\" , function () end ) end ) describe ( \"Secret Feature Y\" , function () it ( \"should do nothing\" , function () -- This code will not run! end ) end ) Note FOCUS does not work inside an it block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.","title":"FOCUS"},{"location":"api-reference/#skip","text":"SKIP() This function works similarly to FOCUS() , except instead of marking a block as focused , it will mark a block as skipped , which stops any of the test assertions in the block from being executed. Note SKIP does not work inside an it block. The bodies of these blocks aren't executed until the tests run, which is too late to change which tests will run.","title":"SKIP"},{"location":"api-reference/#expect","text":"expect(value) Creates a new Expectation , used for testing the properties of the given value. Expectations are intended to be read like English assertions. These are all true: -- Equality expect ( 1 ). to . equal ( 1 ) expect ( 1 ). never . to . equal ( 2 ) -- Approximate equality expect ( 5 ). to . be . near ( 5 + 1e-8 ) expect ( 5 ). to . be . near ( 5 - 1e-8 ) expect ( math.pi ). never . to . be . near ( 3 ) -- Optional limit parameter expect ( math.pi ). to . be . near ( 3 , 0.2 ) -- Nil checking expect ( 1 ). to . be . ok () expect ( false ). to . be . ok () expect ( nil ). never . to . be . ok () -- Type checking expect ( 1 ). to . be . a ( \"number\" ) expect ( newproxy ( true )). to . be . a ( \"userdata\" ) -- Function throwing expect ( function () error ( \"nope\" ) end ). to . throw () expect ( function () -- I don't throw! end ). never . to . throw ()","title":"expect"},{"location":"getting-started/debugging-tests/","text":"Often during development, you'll want to only run the test that's concerned with the specific code you're working on. TestEZ provides the SKIP() and FOCUS() functions to either skip or focus the block that the call is contained in. This mechanism does not work for it blocks; use itSKIP and itFOCUS instead. Code inside it blocks is not run until tests are executed, while describe blocks are run immediately to figure out what tests a project contains. For example, you might want to run the tests targeting a specific method or two for a DateTime module: DateTime.spec.lua return function () describe ( \"new\" , function () FOCUS () it ( \"does really important things\" , function () -- This block will run! end ) end ) itFOCUS ( \"has all methods we expect\" , function () -- Calling FOCUS() would be too late here, so we use itFOCUS instead. -- This block will run, too end ) describe ( \"Format()\" , function () it ( \"formats things\" , function () -- This block will never run! end ) end ) end Warning FOCUS and SKIP are intended exclusively for development. It's not recommended that tests containing these calls are checked into version contorl. Future versions of TeztEZ will be able to detect this when running in a CI system and fail tests to prevent that from happening.","title":"Debugging Tests"},{"location":"getting-started/installation/","text":"In the future, TestEZ will have pre-built model files for use within Roblox without other tools. Method 1: Rojo (Roblox) \u00b6 Copy the src directory into your codebase Rename the folder to TestEZ Use Rojo to sync the files into a place Method 2: Lemur (CI Systems) \u00b6 You can use Lemur paired together with a regular Lua 5.1 interpreter to run tests written with TestEZ. This is the best approach when testing Roblox Lua libraries using existing continuous integration systems like Travis-CI. We use this technique to run tests for Rodux and other libraries.","title":"Installation"},{"location":"getting-started/installation/#method-1-rojo-roblox","text":"Copy the src directory into your codebase Rename the folder to TestEZ Use Rojo to sync the files into a place","title":"Method 1: Rojo (Roblox)"},{"location":"getting-started/installation/#method-2-lemur-ci-systems","text":"You can use Lemur paired together with a regular Lua 5.1 interpreter to run tests written with TestEZ. This is the best approach when testing Roblox Lua libraries using existing continuous integration systems like Travis-CI. We use this technique to run tests for Rodux and other libraries.","title":"Method 2: Lemur (CI Systems)"},{"location":"getting-started/running-tests/","text":"TestEZ provides a convenient method to run tests in a single pass: local TestEZ = require ( < path to TestEZ > ) TestEZ . TestBootstrap : run ({ MY_TESTS }) The method also returns information about the test run that can be used to take further action! The internals of TestEZ are being reworked, so accessing other APIs at this time isn't recommended.","title":"Running Tests"},{"location":"getting-started/writing-tests/","text":"Create .spec.lua files (or Roblox objects with the .spec suffix) for each module you want to test. These modules should return a function that in turn calls functions from TestEZ. A simple module and associated TestEZ spec might look like: Greeter.lua local Greeter = {} function Greeter : greet ( person ) return \"Hello, \" .. person end return Greeter Greeter.spec.lua return function () local Greeter = require ( script . Parent . Greeter ) describe ( \"greet\" , function () it ( \"should include the customary English greeting\" , function () local greeting = Greeter : greet ( \"X\" ) expect ( greeting : match ( \"Hello\" )). to . be . ok () end ) it ( \"should include the person being greeted\" , function () local greeting = Greeter : greet ( \"Joe\" ) expect ( greeting : match ( \"Joe\" )). to . be . ok () end ) end ) end The functions describe , it , and expect are injected by TestEZ and automatically hook into the current testing context. Every module is implicitly scoped according to its path, meaning the tree that the above test represents might be: LuaChat Greeter greet [+] should include the customary English greeting [+] should include the person being greeted","title":"Writing Tests"}]}